// Code generated by sqlgen. DO NOT EDIT!

package model

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/jmoiron/sqlx"
	"xorm.io/builder"
)

// UserModel represents a user model.
type UserModel struct {
	db *sqlx.DB
}

// User represents a user struct data.
type User struct {
	Id         uint64    `db:"id" json:"id"`
	Name       string    `db:"name" json:"name"`
	Password   string    `db:"password" json:"password"`
	Mobile     string    `db:"mobile" json:"mobile"`
	Gender     string    `db:"gender" json:"gender"`
	Nickname   string    `db:"nickname" json:"nickname"`
	Type       int8      `db:"type" json:"type"`
	CreateTime time.Time `db:"create_time" json:"createTime"`
	UpdateTime time.Time `db:"update_time" json:"updateTime"`
}

// FindOneWhereParameter is a where parameter structure.
type FindOneWhereParameter struct {
	IdEqual uint64
}

// FindByNameWhereParameter is a where parameter structure.
type FindByNameWhereParameter struct {
	NameEqual string
}

// FindOnePartWhereParameter is a where parameter structure.
type FindOnePartWhereParameter struct {
	IdEqual uint64
}

// FindByNamePartWhereParameter is a where parameter structure.
type FindByNamePartWhereParameter struct {
	NameEqual string
}

// FindAllCountResult is a find all count result.
type FindAllCountResult struct {
	Count int64 `json:"count"`
}

// FindAllPartCountResult is a find all part count result.
type FindAllPartCountResult struct {
	Count uint64 `json:"count"`
}

// FindOneByNameAndPasswordWhereParameter is a where parameter structure.
type FindOneByNameAndPasswordWhereParameter struct {
	NameEqual     string
	PasswordEqual string
}

// ListUserByNameAscWhereParameter is a where parameter structure.
type ListUserByNameAscWhereParameter struct {
	IdGT uint64
}

// ListUserByNameAscHavingCountTypeGtWhereParameter is a where parameter structure.
type ListUserByNameAscHavingCountTypeGtWhereParameter struct {
	IdGT uint64
}

// ListUserByNameAscHavingCountTypeGtHavingParameter is a having parameter structure.
type ListUserByNameAscHavingCountTypeGtHavingParameter struct {
	TypeCountGT int8
}

// ListUserByNameAscHavingCountTypeGtResult is a list user by name asc having count type gt result.
type ListUserByNameAscHavingCountTypeGtResult struct {
	Id         uint64    `json:"id"`
	Name       string    `json:"name"`
	Password   string    `json:"password"`
	Mobile     string    `json:"mobile"`
	Gender     string    `json:"gender"`
	Nickname   string    `json:"nickname"`
	Type       int8      `json:"type"`
	CreateTime time.Time `json:"createTime"`
	UpdateTime time.Time `json:"updateTime"`
	TypeCount  int8      `json:"typeCount"`
}

// ListUserByNameDescHavingCountTypeGtOrderByIdDescWhereParameter is a where parameter structure.
type ListUserByNameDescHavingCountTypeGtOrderByIdDescWhereParameter struct {
	IdGT uint64
}

// ListUserByNameDescHavingCountTypeGtOrderByIdDescHavingParameter is a having parameter structure.
type ListUserByNameDescHavingCountTypeGtOrderByIdDescHavingParameter struct {
	TypeCountGT int8
}

// ListUserByNameDescHavingCountTypeGtOrderByIdDescResult is a list user by name desc having count type gt order by id desc result.
type ListUserByNameDescHavingCountTypeGtOrderByIdDescResult struct {
	Id         uint64    `json:"id"`
	Name       string    `json:"name"`
	Password   string    `json:"password"`
	Mobile     string    `json:"mobile"`
	Gender     string    `json:"gender"`
	Nickname   string    `json:"nickname"`
	Type       int8      `json:"type"`
	CreateTime time.Time `json:"createTime"`
	UpdateTime time.Time `json:"updateTime"`
	TypeCount  int8      `json:"typeCount"`
}

// ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10WhereParameter is a where parameter structure.
type ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10WhereParameter struct {
	IdGT uint64
}

// ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10HavingParameter is a having parameter structure.
type ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10HavingParameter struct {
	TypeCountGT int8
}

// ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10LimitParameter is a limit parameter structure.
type ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10LimitParameter struct {
	Count int
}

// ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10Result is a list user by name desc having count type gt order by id desc limit 10 result.
type ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10Result struct {
	Id         uint64    `json:"id"`
	Name       string    `json:"name"`
	Password   string    `json:"password"`
	Mobile     string    `json:"mobile"`
	Gender     string    `json:"gender"`
	Nickname   string    `json:"nickname"`
	Type       int8      `json:"type"`
	CreateTime time.Time `json:"createTime"`
	UpdateTime time.Time `json:"updateTime"`
	TypeCount  int8      `json:"typeCount"`
}

// ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10Offset10WhereParameter is a where parameter structure.
type ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10Offset10WhereParameter struct {
	IdGT uint64
}

// ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10Offset10HavingParameter is a having parameter structure.
type ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10Offset10HavingParameter struct {
	TypeCountGT int8
}

// ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10Offset10LimitParameter is a limit parameter structure.
type ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10Offset10LimitParameter struct {
	Count  int
	Offset int
}

// ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10Offset10Result is a list user by name desc having count type gt order by id desc limit 10 offset 10 result.
type ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10Offset10Result struct {
	Id         uint64    `json:"id"`
	Name       string    `json:"name"`
	Password   string    `json:"password"`
	Mobile     string    `json:"mobile"`
	Gender     string    `json:"gender"`
	Nickname   string    `json:"nickname"`
	Type       int8      `json:"type"`
	CreateTime time.Time `json:"createTime"`
	UpdateTime time.Time `json:"updateTime"`
	TypeCount  int8      `json:"typeCount"`
}

// FindOneByNameLikeWhereParameter is a where parameter structure.
type FindOneByNameLikeWhereParameter struct {
	NameLike string
}

// FindAllByNameNotLikeWhereParameter is a where parameter structure.
type FindAllByNameNotLikeWhereParameter struct {
	NameNotLike string
}

// FindAllByIdInWhereParameter is a where parameter structure.
type FindAllByIdInWhereParameter struct {
	IdIn []uint64
}

// FindAllByIdNotInWhereParameter is a where parameter structure.
type FindAllByIdNotInWhereParameter struct {
	IdNotIn []uint64
}

// FindAllByIdBetweenWhereParameter is a where parameter structure.
type FindAllByIdBetweenWhereParameter struct {
	IdBetweenStart uint64
	IdBetweenEnd   uint64
}

// FindAllByIdNotBetweenWhereParameter is a where parameter structure.
type FindAllByIdNotBetweenWhereParameter struct {
	IdNotBetweenStart uint64
	IdNotBetweenEnd   uint64
}

// FindAllByIdGteWhereParameter is a where parameter structure.
type FindAllByIdGteWhereParameter struct {
	IdGE uint64
}

// FindAllByIdLteWhereParameter is a where parameter structure.
type FindAllByIdLteWhereParameter struct {
	IdLE uint64
}

// FindAllByIdNeqWhereParameter is a where parameter structure.
type FindAllByIdNeqWhereParameter struct {
	IdNE uint64
}

// FindAllByIdInOrNotInWhereParameter is a where parameter structure.
type FindAllByIdInOrNotInWhereParameter struct {
	IdIn    []uint64
	IdNotIn []uint64
}

// ComplexQueryWhereParameter is a where parameter structure.
type ComplexQueryWhereParameter struct {
	IdGT                uint64
	IdLT                uint64
	IdNE                uint64
	IdIn                []uint64
	IdNotIn             []uint64
	IdBetweenStart      uint64
	IdBetweenEnd        uint64
	IdNotBetweenStart   uint64
	IdNotBetweenEnd     uint64
	IdGE                uint64
	IdLE                uint64
	IdNE1               uint64
	NameLike            string
	NameNotLike         string
	NameIn              []string
	NameNotIn           []string
	NameBetweenStart    string
	NameBetweenEnd      string
	NameNotBetweenStart string
	NameNotBetweenEnd   string
	NameGE              string
	NameLE              string
	NameNE              string
}

// NewUserModel creates a new user model.
func NewUserModel(db *sqlx.DB) *UserModel {
	return &UserModel{
		db: db,
	}
}

// Create creates  user data.
func (m *UserModel) Create(ctx context.Context, data ...*User) (err error) {
	if len(data) == 0 {
		return fmt.Errorf("data is empty")
	}

	var stmt *sql.Stmt
	stmt, err = m.db.PrepareContext(ctx, "INSERT INTO user (`name`, `password`, `mobile`, `gender`, `nickname`, `type`, `create_time`, `update_time`) VALUES (?, ?, ?, ?, ?, ?, ?, ?)")
	if err != nil {
		return
	}
	defer func() {
		err = stmt.Close()
	}()
	for _, v := range data {
		result, err := stmt.ExecContext(ctx, v.Name, v.Password, v.Mobile, v.Gender, v.Nickname, v.Type, v.CreateTime, v.UpdateTime)
		if err != nil {
			return err
		}

		id, err := result.LastInsertId()
		if err != nil {
			return err
		}

		v.Id = uint64(id)
	}
	return
}

// FindOne is generated from sql:
// select * from user where id = ? limit 1;
func (m *UserModel) FindOne(ctx context.Context, where FindOneWhereParameter) (result *User, err error) {
	result = new(User)
	b := builder.Select(`*`)
	b.From("`user`")
	b.Where(builder.Expr(`id = ?`, where.IdEqual))
	b.Limit(1)
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v User
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = &v
		break
	}

	return result, nil
}

// FindByName is generated from sql:
// select * from user where name = ? limit 1;
func (m *UserModel) FindByName(ctx context.Context, where FindByNameWhereParameter) (result *User, err error) {
	result = new(User)
	b := builder.Select(`*`)
	b.From("`user`")
	b.Where(builder.Expr(`name = ?`, where.NameEqual))
	b.Limit(1)
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v User
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = &v
		break
	}

	return result, nil
}

// FindOnePart is generated from sql:
// select id, name, nickname from user where id = ? limit 1;
func (m *UserModel) FindOnePart(ctx context.Context, where FindOnePartWhereParameter) (result *User, err error) {
	result = new(User)
	b := builder.Select(`id, name, nickname`)
	b.From("`user`")
	b.Where(builder.Expr(`id = ?`, where.IdEqual))
	b.Limit(1)
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v User
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = &v
		break
	}

	return result, nil
}

// FindByNamePart is generated from sql:
// select id, name, nickname from user where name = ? limit 1;
func (m *UserModel) FindByNamePart(ctx context.Context, where FindByNamePartWhereParameter) (result *User, err error) {
	result = new(User)
	b := builder.Select(`id, name, nickname`)
	b.From("`user`")
	b.Where(builder.Expr(`name = ?`, where.NameEqual))
	b.Limit(1)
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v User
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = &v
		break
	}

	return result, nil
}

// FindAll is generated from sql:
// select * from user;
func (m *UserModel) FindAll(ctx context.Context) (result []*User, err error) {
	b := builder.Select(`*`)
	b.From("`user`")
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v User
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = append(result, &v)
	}

	return result, nil
}

// FindAllCount is generated from sql:
// select count(*) AS count from user;
func (m *UserModel) FindAllCount(ctx context.Context) (result *FindAllCountResult, err error) {
	result = new(FindAllCountResult)
	b := builder.Select(`count(1) AS count`)
	b.From("`user`")
	b.Limit(1)
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v FindAllCountResult
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = &v
		break
	}

	return result, nil
}

// FindAllPart is generated from sql:
// select id, name, nickname from user;
func (m *UserModel) FindAllPart(ctx context.Context) (result []*User, err error) {
	b := builder.Select(`id, name, nickname`)
	b.From("`user`")
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v User
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = append(result, &v)
	}

	return result, nil
}

// FindAllPartCount is generated from sql:
// select count(id) AS count from user;
func (m *UserModel) FindAllPartCount(ctx context.Context) (result *FindAllPartCountResult, err error) {
	result = new(FindAllPartCountResult)
	b := builder.Select(`count(id) AS count`)
	b.From("`user`")
	b.Limit(1)
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v FindAllPartCountResult
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = &v
		break
	}

	return result, nil
}

// FindOneByNameAndPassword is generated from sql:
// select * from user where name = ? and password = ? limit 1;
func (m *UserModel) FindOneByNameAndPassword(ctx context.Context, where FindOneByNameAndPasswordWhereParameter) (result *User, err error) {
	result = new(User)
	b := builder.Select(`*`)
	b.From("`user`")
	b.Where(builder.Expr(`name = ? AND password = ?`, where.NameEqual, where.PasswordEqual))
	b.Limit(1)
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v User
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = &v
		break
	}

	return result, nil
}

// ListUserByNameAsc is generated from sql:
// select * from user where id > ? group by name;
func (m *UserModel) ListUserByNameAsc(ctx context.Context, where ListUserByNameAscWhereParameter) (result []*User, err error) {
	b := builder.Select(`*`)
	b.From("`user`")
	b.Where(builder.Expr(`id > ?`, where.IdGT))
	b.GroupBy(`name`)
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v User
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = append(result, &v)
	}

	return result, nil
}

// ListUserByNameAscHavingCountTypeGt is generated from sql:
// select *, count(type) AS typeCount from user where id > ? group by name having typeCount > ?;
func (m *UserModel) ListUserByNameAscHavingCountTypeGt(ctx context.Context, where ListUserByNameAscHavingCountTypeGtWhereParameter, having ListUserByNameAscHavingCountTypeGtHavingParameter) (result []*ListUserByNameAscHavingCountTypeGtResult, err error) {
	b := builder.Select(`*, count(type) AS typeCount`)
	b.From("`user`")
	b.Where(builder.Expr(`id > ?`, where.IdGT))
	b.GroupBy(`name`)
	b.Having(fmt.Sprintf(`typeCount > %v`, having.TypeCountGT))
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v ListUserByNameAscHavingCountTypeGtResult
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = append(result, &v)
	}

	return result, nil
}

// ListUserByNameDescHavingCountTypeGtOrderByIdDesc is generated from sql:
// select *, count(type) AS typeCount from user where id > ? group by name having typeCount > ? order by id desc;
func (m *UserModel) ListUserByNameDescHavingCountTypeGtOrderByIdDesc(ctx context.Context, where ListUserByNameDescHavingCountTypeGtOrderByIdDescWhereParameter, having ListUserByNameDescHavingCountTypeGtOrderByIdDescHavingParameter) (result []*ListUserByNameDescHavingCountTypeGtOrderByIdDescResult, err error) {
	b := builder.Select(`*, count(type) AS typeCount`)
	b.From("`user`")
	b.Where(builder.Expr(`id > ?`, where.IdGT))
	b.GroupBy(`name`)
	b.Having(fmt.Sprintf(`typeCount > %v`, having.TypeCountGT))
	b.OrderBy(`id desc`)
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v ListUserByNameDescHavingCountTypeGtOrderByIdDescResult
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = append(result, &v)
	}

	return result, nil
}

// ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10 is generated from sql:
// select *, count(type) AS typeCount from user where id > ? group by name having typeCount > ? order by id desc limit 10;
func (m *UserModel) ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10(ctx context.Context, where ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10WhereParameter, having ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10HavingParameter, limit ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10LimitParameter) (result []*ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10Result, err error) {
	b := builder.Select(`*, count(type) AS typeCount`)
	b.From("`user`")
	b.Where(builder.Expr(`id > ?`, where.IdGT))
	b.GroupBy(`name`)
	b.Having(fmt.Sprintf(`typeCount > %v`, having.TypeCountGT))
	b.OrderBy(`id desc`)
	b.Limit(limit.Count)
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10Result
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = append(result, &v)
	}

	return result, nil
}

// ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10Offset10 is generated from sql:
// select *, count(type) AS typeCount from user where id > ? group by name having typeCount > ? order by id desc limit 10, 10;
func (m *UserModel) ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10Offset10(ctx context.Context, where ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10Offset10WhereParameter, having ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10Offset10HavingParameter, limit ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10Offset10LimitParameter) (result []*ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10Offset10Result, err error) {
	b := builder.Select(`*, count(type) AS typeCount`)
	b.From("`user`")
	b.Where(builder.Expr(`id > ?`, where.IdGT))
	b.GroupBy(`name`)
	b.Having(fmt.Sprintf(`typeCount > %v`, having.TypeCountGT))
	b.OrderBy(`id desc`)
	b.Limit(limit.Count, limit.Offset)
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v ListUserByNameDescHavingCountTypeGtOrderByIdDescLimit10Offset10Result
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = append(result, &v)
	}

	return result, nil
}

// FindOneByNameLike is generated from sql:
// select * from user where name like ? limit 1;
func (m *UserModel) FindOneByNameLike(ctx context.Context, where FindOneByNameLikeWhereParameter) (result *User, err error) {
	result = new(User)
	b := builder.Select(`*`)
	b.From("`user`")
	b.Where(builder.Expr(`name LIKE ?`, where.NameLike))
	b.Limit(1)
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v User
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = &v
		break
	}

	return result, nil
}

// FindAllByNameNotLike is generated from sql:
// select * from user where name not like ?;
func (m *UserModel) FindAllByNameNotLike(ctx context.Context, where FindAllByNameNotLikeWhereParameter) (result []*User, err error) {
	b := builder.Select(`*`)
	b.From("`user`")
	b.Where(builder.Expr(`name NOT LIKE ?`, where.NameNotLike))
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v User
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = append(result, &v)
	}

	return result, nil
}

// FindAllByIdIn is generated from sql:
// select * from user where id in (?);
func (m *UserModel) FindAllByIdIn(ctx context.Context, where FindAllByIdInWhereParameter) (result []*User, err error) {
	b := builder.Select(`*`)
	b.From("`user`")
	b.Where(builder.Expr(`id IN (?)`, where.IdIn))
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v User
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = append(result, &v)
	}

	return result, nil
}

// FindAllByIdNotIn is generated from sql:
// select * from user where id not in (?);
func (m *UserModel) FindAllByIdNotIn(ctx context.Context, where FindAllByIdNotInWhereParameter) (result []*User, err error) {
	b := builder.Select(`*`)
	b.From("`user`")
	b.Where(builder.Expr(`id NOT IN (?)`, where.IdNotIn))
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v User
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = append(result, &v)
	}

	return result, nil
}

// FindAllByIdBetween is generated from sql:
// select * from user where id between ? and ?;
func (m *UserModel) FindAllByIdBetween(ctx context.Context, where FindAllByIdBetweenWhereParameter) (result []*User, err error) {
	b := builder.Select(`*`)
	b.From("`user`")
	b.Where(builder.Expr(`id BETWEEN ? AND ?`, where.IdBetweenStart, where.IdBetweenEnd))
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v User
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = append(result, &v)
	}

	return result, nil
}

// FindAllByIdNotBetween is generated from sql:
// select * from user where id not between ? and ?;
func (m *UserModel) FindAllByIdNotBetween(ctx context.Context, where FindAllByIdNotBetweenWhereParameter) (result []*User, err error) {
	b := builder.Select(`*`)
	b.From("`user`")
	b.Where(builder.Expr(`id NOT BETWEEN ? AND ?`, where.IdNotBetweenStart, where.IdNotBetweenEnd))
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v User
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = append(result, &v)
	}

	return result, nil
}

// FindAllByIdGte is generated from sql:
// select * from user where id >= ?;
func (m *UserModel) FindAllByIdGte(ctx context.Context, where FindAllByIdGteWhereParameter) (result []*User, err error) {
	b := builder.Select(`*`)
	b.From("`user`")
	b.Where(builder.Expr(`id >= ?`, where.IdGE))
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v User
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = append(result, &v)
	}

	return result, nil
}

// FindAllByIdLte is generated from sql:
// select * from user where id <= ?;
func (m *UserModel) FindAllByIdLte(ctx context.Context, where FindAllByIdLteWhereParameter) (result []*User, err error) {
	b := builder.Select(`*`)
	b.From("`user`")
	b.Where(builder.Expr(`id <= ?`, where.IdLE))
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v User
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = append(result, &v)
	}

	return result, nil
}

// FindAllByIdNeq is generated from sql:
// select * from user where id != ?;
func (m *UserModel) FindAllByIdNeq(ctx context.Context, where FindAllByIdNeqWhereParameter) (result []*User, err error) {
	b := builder.Select(`*`)
	b.From("`user`")
	b.Where(builder.Expr(`id != ?`, where.IdNE))
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v User
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = append(result, &v)
	}

	return result, nil
}

// FindAllByIdInOrNotIn is generated from sql:
// select * from user where id in (?) or id not in (?);
func (m *UserModel) FindAllByIdInOrNotIn(ctx context.Context, where FindAllByIdInOrNotInWhereParameter) (result []*User, err error) {
	b := builder.Select(`*`)
	b.From("`user`")
	b.Where(builder.Expr(`id IN (?) OR id NOT IN (?)`, where.IdIn, where.IdNotIn))
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v User
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = append(result, &v)
	}

	return result, nil
}

// ComplexQuery is generated from sql:
// select * from user where id > ? and id < ? and id != ? and id in (?) and id not in (?) and id between ? and ? and id not between ? and ? and id >= ? and id <= ? and id != ? and name like ? and name not like ? and name in (?) and name not in (?) and name between ? and ? and name not between ? and ? and name >= ? and name <= ? and name != ?;
func (m *UserModel) ComplexQuery(ctx context.Context, where ComplexQueryWhereParameter) (result []*User, err error) {
	b := builder.Select(`*`)
	b.From("`user`")
	b.Where(builder.Expr(`id > ? AND id < ? AND id != ? AND id IN (?) AND id NOT IN (?) AND id BETWEEN ? AND ? AND id NOT BETWEEN ? AND ? AND id >= ? AND id <= ? AND id != ? AND name LIKE ? AND name NOT LIKE ? AND name IN (?) AND name NOT IN (?) AND name BETWEEN ? AND ? AND name NOT BETWEEN ? AND ? AND name >= ? AND name <= ? AND name != ?`, where.IdGT, where.IdLT, where.IdNE, where.IdIn, where.IdNotIn, where.IdBetweenStart, where.IdBetweenEnd, where.IdNotBetweenStart, where.IdNotBetweenEnd, where.IdGE, where.IdLE, where.IdNE1, where.NameLike, where.NameNotLike, where.NameIn, where.NameNotIn, where.NameBetweenStart, where.NameBetweenEnd, where.NameNotBetweenStart, where.NameNotBetweenEnd, where.NameGE, where.NameLE, where.NameNE))
	query, args, err := b.ToSQL()
	var rows *sqlx.Rows
	rows, err = m.db.QueryxContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		err = rows.Close()
		if err != nil {
			result = nil
		}
	}()

	for rows.Next() {
		var v User
		err = rows.StructScan(&v)
		if err != nil {
			return nil, err
		}
		result = append(result, &v)
	}

	return result, nil
}
