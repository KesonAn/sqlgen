// Code generated by sqlgen. DO NOT EDIT!

package model

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"xorm.io/builder"
)

// UserModel represents a user model.
type UserModel struct {
	db      *sql.Conn
	scanner Scanner
}

// User represents a user struct data.
type User struct {
	Id         uint64    `json:"id"`
	Name       string    `json:"name"`
	Password   string    `json:"password"`
	Mobile     string    `json:"mobile"`
	Gender     string    `json:"gender"`
	Nickname   string    `json:"nickname"`
	Type       int8      `json:"type"`
	CreateTime time.Time `json:"createTime"`
	UpdateTime time.Time `json:"updateTime"`
}

// UpdateWhereParameter is a where parameter structure.
type UpdateWhereParameter struct {
	IdEqual uint64
}

// UpdateByNameWhereParameter is a where parameter structure.
type UpdateByNameWhereParameter struct {
	NameEqual string
}

// UpdatePartWhereParameter is a where parameter structure.
type UpdatePartWhereParameter struct {
	IdEqual uint64
}

// UpdatePartByNameWhereParameter is a where parameter structure.
type UpdatePartByNameWhereParameter struct {
	NameEqual string
}

// UpdateNameLimitWhereParameter is a where parameter structure.
type UpdateNameLimitWhereParameter struct {
	IdGT uint64
}

// UpdateNameLimitLimitParameter is a limit parameter structure.
type UpdateNameLimitLimitParameter struct {
	Count int
}

// UpdateNameLimitOrderWhereParameter is a where parameter structure.
type UpdateNameLimitOrderWhereParameter struct {
	IdGT uint64
}

// UpdateNameLimitOrderLimitParameter is a limit parameter structure.
type UpdateNameLimitOrderLimitParameter struct {
	Count int
}

// NewUserModel creates a new user model.
func NewUserModel(db *sql.Conn, scanner Scanner) *UserModel {
	return &UserModel{
		db:      db,
		scanner: scanner,
	}
}

// Create creates  user data.
func (m *UserModel) Create(ctx context.Context, data ...*User) (err error) {
	if len(data) == 0 {
		return fmt.Errorf("data is empty")
	}

	var stmt *sql.Stmt
	stmt, err = m.db.PrepareContext(ctx, "INSERT INTO user (`name`, `password`, `mobile`, `gender`, `nickname`, `type`, `create_time`, `update_time`) VALUES (?, ?, ?, ?, ?, ?, ?, ?)")
	if err != nil {
		return
	}
	defer func() {
		err = stmt.Close()
	}()
	for _, v := range data {
		_, err = stmt.ExecContext(ctx, v.Name, v.Password, v.Mobile, v.Gender, v.Nickname, v.Type, v.CreateTime, v.UpdateTime)
		if err != nil {
			return
		}
	}
	return
}

// Update is generated from sql:
// update user set name = ?, password = ?, mobile = ?, gender = ?, nickname = ?, type = ?, create_time = ?, update_time = ? where id = ?;
func (m *UserModel) Update(ctx context.Context, data *User, where UpdateWhereParameter) error {
	b := builder.Update(builder.Eq{
		"name":        data.Name,
		"password":    data.Password,
		"mobile":      data.Mobile,
		"gender":      data.Gender,
		"nickname":    data.Nickname,
		"type":        data.Type,
		"create_time": data.CreateTime,
		"update_time": data.UpdateTime,
	})
	b.From("`user`")
	b.Where(builder.Expr(`id = ?`, where.IdEqual))
	query, args, err := b.ToSQL()
	if err != nil {
		return err
	}
	_, err = m.db.ExecContext(ctx, query, args...)
	return err
}

// UpdateByName is generated from sql:
// update user set password = ?, mobile = ?, gender = ?, nickname = ?, type = ?, create_time = ?, update_time = ? where name = ?;
func (m *UserModel) UpdateByName(ctx context.Context, data *User, where UpdateByNameWhereParameter) error {
	b := builder.Update(builder.Eq{
		"password":    data.Password,
		"mobile":      data.Mobile,
		"gender":      data.Gender,
		"nickname":    data.Nickname,
		"type":        data.Type,
		"create_time": data.CreateTime,
		"update_time": data.UpdateTime,
	})
	b.From("`user`")
	b.Where(builder.Expr(`name = ?`, where.NameEqual))
	query, args, err := b.ToSQL()
	if err != nil {
		return err
	}
	_, err = m.db.ExecContext(ctx, query, args...)
	return err
}

// UpdatePart is generated from sql:
// update user set name = ?, nickname = ? where id = ?;
func (m *UserModel) UpdatePart(ctx context.Context, data *User, where UpdatePartWhereParameter) error {
	b := builder.Update(builder.Eq{
		"name":     data.Name,
		"nickname": data.Nickname,
	})
	b.From("`user`")
	b.Where(builder.Expr(`id = ?`, where.IdEqual))
	query, args, err := b.ToSQL()
	if err != nil {
		return err
	}
	_, err = m.db.ExecContext(ctx, query, args...)
	return err
}

// UpdatePartByName is generated from sql:
// update user set name = ?, nickname = ? where name = ?;
func (m *UserModel) UpdatePartByName(ctx context.Context, data *User, where UpdatePartByNameWhereParameter) error {
	b := builder.Update(builder.Eq{
		"name":     data.Name,
		"nickname": data.Nickname,
	})
	b.From("`user`")
	b.Where(builder.Expr(`name = ?`, where.NameEqual))
	query, args, err := b.ToSQL()
	if err != nil {
		return err
	}
	_, err = m.db.ExecContext(ctx, query, args...)
	return err
}

// UpdateNameLimit is generated from sql:
// update user set name = ? where id > ? limit ?;
func (m *UserModel) UpdateNameLimit(ctx context.Context, data *User, where UpdateNameLimitWhereParameter, limit UpdateNameLimitLimitParameter) error {
	b := builder.Update(builder.Eq{
		"name": data.Name,
	})
	b.From("`user`")
	b.Where(builder.Expr(`id > ?`, where.IdGT))
	b.Limit(limit.Count)
	query, args, err := b.ToSQL()
	if err != nil {
		return err
	}
	_, err = m.db.ExecContext(ctx, query, args...)
	return err
}

// UpdateNameLimitOrder is generated from sql:
// update user set name = ? where id > ? order by id desc limit ?;
func (m *UserModel) UpdateNameLimitOrder(ctx context.Context, data *User, where UpdateNameLimitOrderWhereParameter, limit UpdateNameLimitOrderLimitParameter) error {
	b := builder.Update(builder.Eq{
		"name": data.Name,
	})
	b.From("`user`")
	b.Where(builder.Expr(`id > ?`, where.IdGT))
	b.OrderBy(`id desc`)
	b.Limit(limit.Count)
	query, args, err := b.ToSQL()
	if err != nil {
		return err
	}
	_, err = m.db.ExecContext(ctx, query, args...)
	return err
}
